# 2867 - 수열의 값

<https://www.acmicpc.net/problem/2867> p4

모노토닉 스택 응용 문제입니다.

이 문제의 특징은, 최대와 최소를 꼭 부분 구간마다 묶어서 생각할 필요 없이 독립적으로 볼 수 있다는 것입니다.
예컨대 숫자 5가 최소인 구간이 8개 있으면 최종 결과에 -40 하기만 하면 되고, 그때 8개 구간의 각 최대는 몰라도 됩니다.

이에 착안해 minStack과 maxStack을 각각 씁니다.
전자는 increasing, 후자는 decreasing 스택입니다.
그렇게 하면 minStack과 maxStack 사이에 숫자가 오간다던지 하는 교류가 일절 없습니다.

핵심 로직을 minStack을 기준으로 설명하겠습니다.

스택에 있는 각 값은, 스택의 다음 값(더 작은 값)과 다음에 스택에 들어올 더 작은 값 사이의 local min입니다.
이때 왼쪽 각 값의 왼쪽 방향에 자신보다 더 큰 값들, 즉 자기가 local min인 부분구간에 포함될 왼쪽 방향 원소의 개수를 `leftCount`로 함께 저장합니다.

첫째, 새로 원소가 들어왔을 때 스택 피크보다 크다면 → local min에 어떠한 영향도 없으므로 그냥 무시합니다.

둘째, 새로 원소가 들어왔을 때 스택 피크보다 작다면 →

1. pop해서 해당 원소가 local min인 부분 구간의 개수를 구하고 점수에 반영합니다.
2. pop한 원소의 `leftCount` 에 +1 (pop한 원소 자신도 카운트). 이 값을 pop할 때마다 누산한 값을 다음 피크의 오른쪽 방향 원소의 개수로 삼습니다. 코드상에서 `rightCount`입니다.
3. 최종 `rightCount` 는 최종 스택 피크(새 원소보다 더 작은 값)의 오른쪽 방향으로 새 원소 직전까지의 원소 개수를 의미합니다. 이는 곧 새 원소의 `leftCount` 로 볼 수 있습니다.

셋째, 같은 값이면 → 그냥 팝해서 하나로 뭉갭니다.

이때 스택의 값이 local min인 부분 구간의 개수는 다음과 같습니다.

((local min의 왼쪽 원소 수) + 1) * ((local min의 오른쪽의 원소 수) + 1) - 1

이것은 (부분구간의 시작점 경우의 수) * (부분 구간의 끝점 경우의 수)를 의미합니다.
수식에서 +1은 자기 자신을 카운팅한 거고, -1은 자기 자신만 들어있는 1개짜리 부분구간을 제외한 것입니다.
크기가 1인 부분구간을 제외하는 이유는 어차피 원소가 1개여서 최대 최소가 똑같기 때문입니다.

예컨대 {2, **1**, 3, 5}에 대해서 세로축은 시작점, 가로축은 끝점인 표로 나타내면 다음과 같습니다.

| - | 1 | 2 | 5 |
| --- | --- | --- | --- |
| 1 | {1} | {1, 2} | {1, 2, 5} |
| 3 | {3, 1} | {3, 1, 2} | {3, 1, 2, 5} |

이걸 토대로 결과에 반영할 숫자를 합산하는 게 `calculatedResultOfAffectedRangesByPopped`입니다.
최솟값 계산이면 결과에서 빼면 되고, 최댓값 계산이면 더하면 됩니다.

마지막으로 스택을 다 비우면서 똑같은 과정 거치면 됩니다.

결과는 대략 최대 30만 * 1억이므로 Long 사용이 필요합니다.
중간 계산 결과들도 Long으로 두어야 합니다.
