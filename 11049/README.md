# 11049번 "행렬 곱셈 순서" 풀이 및 후기

| 바로가기  | <https://www.acmicpc.net/problem/11049> |
|-------|-----------------------------------------|
| 레이팅   | g3                                      |
| 푼 날짜  | 2023-08-12                              |
| 걸린 시간 | 1h 45h +@                               |

## 후기

정석 DP 그 자체입니다.
이걸 풀었다면 정석 DP를 어느 정도 이해했다고 느끼게 될 것 같네요.
그래서 꽤나 추천하고 싶은 문제입니다.
우매함의 봉우리 고점에 서있는 느낌을 받기 좋습니다.

그리디인 줄 알고 삽질한 게 30분, 샤워하다 갑자기 아이디어 떠오른 게 알파, 그 뒤로 사실 잘못된 아이디어였지만 그래도 실마리를 찾았다 생각하고 고생한 게 75분...

## 풀이

모든 경우의 수를 완전 탐색 하면 O(N!)이므로 불가능합니다.

그리디나 분할 정복은 불가능합니다.
반례를 찾다보면 찾을 수 있습니다.

우선 i번째 행렬의 column 수와 i+1번째 행렬의 row 수는 항상 같습니다.
따라서 입력 배열을 N+1 크기로 flatten 할 수 있습니다.
예제 입력은 {5, 3, 2, 6} 이렇게 바뀝니다.
3은 첫 행렬의 column 수이자 두번째 행렬의 row 수입니다.

연산 횟수 계산은 이 점을 이용합시다.
`right = left + 2` 인 경우에 한정해 `calculate(left, right) = sizes[left] * sizes[left + 1] * sizes[left + 2]` 입니다.
뒤에서 이 `calculate`를 일반화해서 dp로 표기하기로 합시다.
또한 flatten 은 나중에 DP 점화식을 코딩할 때 두 행렬 묶음의 인접점을 표기하기에도 편합니다.

`dp(left, right)`를 left번째 사이즈부터 right번째 사이즈까지에 해당하는 행렬들을 곱하는 최소 연산 횟수라고 합시다.

left = 0, right = n, i = 1..(n-1) 에 대해, 다음을 구합니다.
`min(dp(left, i) + dp(i, right) + (sizes[left] *sizes[i]* sizes[right]))`

예컨대 5개의 행렬의 곱 ABCDE를 다음들로 쪼개고, 그 중 min을 고르는 것입니다.

- *A 최소 횟수* + BCDE 최소 횟수 + (A)(BCDE) 횟수
- AB 최소 횟수 + CDE 최소 횟수 + (AB)(CDE) 횟수
- ABC 최소 횟수 + DE 최소 횟수 + (ABC)(DE) 횟수
- ABCD 최소 횟수 + *E 최소 횟수* + (ABCD)(E) 횟수

이렇게 쪼개는 것이 ABCDE를 쪼갤 수 있는 모든 경우를 다 구한 것입니다.

이때 기울임해둔 A 그 자체랑 E 그 자체는 아무 곱셈도 안 한다는 것이므로 연산 횟수가 0입니다.
즉 무시 대상이지만, DP 일반화를 위해 살려두었습니다.
코드에서는 DP 내의 기저사례인 if (left + 2 > right) return 0 으로 처리합니다.

위 ABCDE 사례를 식으로 표현하면

- dp(0, 1) + dp(1, 5) + (sizes[0] *sizes[1]* sizes[5])
- dp(0, 2) + dp(2, 5) + (sizes[0] *sizes[2]* sizes[5])
- dp(0, 3) + dp(3, 5) + (sizes[0] *sizes[3]* sizes[5])
- dp(0, 4) + dp(4, 5) + (sizes[0] *sizes[4]* sizes[5])

이렇게 4개의 식이 나옵니다.
이 중에서 min을 고른 것이 dp(0, 5)가 됩니다.

기저 사례 하나는 위에서 언급한 행렬을 1개만 고른 경우입니다.
`dp(left, left + 1) = 0`

기저 사례 또 하나는 행렬을 2개만 고른 경우입니다.
맨 위의 calculate를 참조합시다.
`dp(left, left + 2) = sizes[left] *sizes[left + 1]* sizes[left + 2]`

최종 O(N^3) 입니다.
N^3 = 125,000,000 이므로 시간 내에 해결할 수 있습니다.
