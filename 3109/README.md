# 3109번 "빵집" 풀이 및 후기

| 바로가기  | <https://www.acmicpc.net/problem/3109> |
|-------|----------------------------------------|
| 레이팅   | g2                                     |
| 푼 날짜  | 2023-08-22                             |
| 걸린 시간 | 30m                                    |

## 후기

삽질에 시간을 꽤 썼습니다.
그러다가 이렇게 하면 되지 않나? 생각하고 실제로 구현하는데는 5분정도 걸렸네요.

풀고 좀 심심해서, 코드 살짝 마개조해서 숏코딩 1등해봤습니다.

## 풀이

DFS. 그리디 느낌도 약간 납니다.

위치(x, y)가 이동 가능할 때, (x+1, y-1), (x+1, y), (x+1, y+1)를 차례로 DFS stack에 넣습니다.
스택에 넣는 순서는 경로를 최대한 위쪽에 달라붙게 하겠다는 의미입니다.
경로들이 마치 무지개처럼 겹겹이 쌓인 걸 상상해봅시다.

위치에 한 번 이동했으면 그 위치를 이동 불가능으로 처리해서 재탐색을 막습니다.
한 위치에서는 최대 하나의 경로만 나올 수 있고, 한 번 경로를 못 찾은 위치는 무조건 후보에서 제외되기 때문입니다.
즉, 재방문할 일이 절대 없다는 것입니다.

오른쪽 끝점에 도달하면 경로를 찾은 것이므로 true를 재귀적으로 반환합니다.

이 dfs를 y=0, 1, ..., r-1 순서로, 즉 위쪽부터 하나씩 체크해 가능한 경로(true)의 개수를 셉니다.

모든 점을 한 번씩 체크해야 하고, 각 점에 연결된 간선이 3개 이내로 고정되어 있습니다.
따라서 시간복잡도는 O(R * C) 입니다.
재귀 스택은 최대 C개까지 쌓입니다.

---

숏코드

`m[y][x]=='x'` 보다 `m[y][x]>'w'`가 한 글자 더 짧습니다.
코틀린이 Char, Int 바로 비교가 안 돼서 아쉽더군요.

dfs의 반환 타입이 Int인 것보다 Boolean인게 뒤에서 any, count를 바로 쓸 수 있어서 더 짧습니다.

이런 식으로 기를 쓰고 글자 줄이려고 노력했습니다.
