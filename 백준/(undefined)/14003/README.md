# 14003번 "가장 긴 증가하는 부분 수열 5" 풀이 및 후기

| 바로가기  | <https://www.acmicpc.net/problem/14003> |
|-------|-----------------------------------------|
| 레이팅   | p5                                      |
| 푼 날짜  | 2023-08-08                              |
| 걸린 시간 | 2h 25m                                  |

## 후기

[14002](../14002) 시리즈입니다.
[12738](../12738) 확장판입니다.

오로지 경로 역추적만 들어갔는데 g2 -> p5로 오른 문제입니다.

2h는 [12738](../12738) 푼데 걸린 시간입니다.
DP 감수성 어렵네요...

## 풀이

`minValuesWhereIndexAsLength`는 DP 배열입니다.
DP 관련 자세한 설명은 [12738](../12738)에 있습니다.
따라서 이 문제의 추가 요소인 결과 예시 추적만 설명하겠습니다.

주어진 배열 `array`를 순회할 때, 특정 시점의 부분 수열 길이별 마지막 값(tail) 위치를 저장하는 배열 `minValueIndices`을 만듭니다.
이 위치 배열의 인덱스 `i`는 부분 수열 길이를 의미합니다.
제 코드상에서는 i는 0부터 시작하므로 길이 - 1이긴 한데, 그냥 인덱스 0은 패딩하고 1부터 시작하게 해도 됩니다.
값인 `array[i]` 특정 시점에서 길이가 i인 부분 수열들의 tail들 중 가장 작은 원소의 위치를 의미합니다.
이 배열은 매 순회마다 값이 바뀔 수 있습니다.

이제 `array`의 각 원소가 자기가 있을 수 있는 부분 수열 중 가장 긴 부분수열에 있을 때, 그 원소의 왼쪽(부모) 원소 위치를 저장할 배열 `parents`를 만듭니다.
x에 대해 `parents[x]`는 `array[x]`의 부모 원소의 인덱스를 의미합니다.
이 배열의 각 원소는 값이 정해지면 바뀌지 않습니다.
`minValueIndices`가 매 순회마다 값이 바뀔 수 있으므로, 고정된 저장소로 쓰기 위해 만든 배열입니다.

DP 배열을 업데이트하는 상황, 즉 같은 길이인 부분 수열에 대한 더 작은 tail 값이나, 더 긴 길이의 부분 수열을 형성할 값을 찾았다면 다음을 수행합니다.

- `minValueIndices[foundLength]`를 현재 원소의 인덱스인 `currentIndex`로 업데이트합니다. 해당 길이 부분 수열을 새로 찾았거나, 아니면 더 작은 값이 tail인 부분 수열을 찾았거나 입니다.
- `parents[currentIndex]`를 `minValueIndices[foundLength - 1]`로 업데이트합니다. 부모 원소는 길이가 1 작은 부분 수열의 tail이므로 그것의 인덱스를 저장합니다. 이때 부모가
  없는 head라면 -1로 표기합니다

다 끝났으면 `parents[minValueIndices[maxLength]]`부터 시작해서 역추적하면 됩니다.

능력이 된다면 트리 등을 써서 경로를 표현해도 될 것 같습니다.
그 편이 더 직관적일 수도 있구요.
