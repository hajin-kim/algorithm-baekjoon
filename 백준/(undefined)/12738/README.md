# 12738번 "가장 긴 증가하는 부분 수열 3" 풀이 및 후기

| 바로가기  | <https://www.acmicpc.net/problem/12738> |
|-------|-----------------------------------------|
| 레이팅   | g2                                      |
| 푼 날짜  | 2023-08-08                              |
| 걸린 시간 | 2h                                      |

## 후기

[14002](../14002) 시리즈입니다.
저건 4번이고 이게 3번인데, 이게 더 어렵습니다.
문제 제약사항 보면 짐작 가능하듯 N log N이 필수이기 때문입니다.

DP 감수성 어렵네요...

## 풀이

DP를 특이하게 씁니다다.
배열 `dp`의 인덱스 i는 부분수열의 길이를 의미합니다.
dp[i]는 **현재까지 체크한 원소들 중** 길이가 i인 부분 수열의 마지막 수(tail)들 중 **가장 작은 것**을 의미합니다.
dp는 항상 유니크하고 오름차순 정렬된 배열로 유지되는 것이 특징입니다.

만약 새 원소가 dp의 마지막 원소보다 크다면, dp 배열의 끝자락에 추가합니다.
dp의 마지막 원소는 최장 부분 수열의 tail(마지막 원소)입니다.
따라서 이는 기존의 최장 부분 수열에 새 원소를 추가하는 것과 같습니다.

만약 새 원소가 dp의 어느 두 원소 사이에 있다면...
그 둘 중 오른쪽(더 큰) 원소와 새 원소를 비교합니다.
만약 새 원소가 더 작다면 오른쪽 원소의 값을 새 원소로 덮어씌웁니다.
이는 길이가 같은데 tail이 더 작은 부분수열을 찾았다는 의미입니다.
왼쪽(더 작은) 원소까지의 부분수열에 새 값을 추가하는 것과도 같습니다.

만약 새 원소가 dp의 어느 원소와 같다면, 무시하고 넘어갑니다.

이때 새 원소가 dp의 어느 위치에 있는지 찾기 위해 **binary search**를 사용합니다.
dp를 오름차순 정렬로 유지하기 때문에 가능합니다.
그러면 최대 N번 binary search를 수행하므로 최종 시간복잡도가 $O(N log N)$ 입니다.

dp 배열은 미리 크기 n, 기본값 Int.MAX_VALUE를 채워놓고 시작합니다.
그리고 별도의 최대 길이 카운터를 만들어두고, 마지막에 이 카운터를 출력하면 됩니다.
