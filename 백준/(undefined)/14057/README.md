# 14057번 "Towers" 풀이 및 후기

| 바로가기  | <https://www.acmicpc.net/problem/14057> |
|-------|-----------------------------------------|
| 레이팅   | p3                                      |
| 푼 날짜  | 2023-08-07                              |
| 걸린 시간 | 2h                                      |

## 후기

엣지 케이스 찾아 삼만리...
눈물 날 뻔 했네요.

영어 문제에 익숙치 않은 것도 있었습니다.
이건 많이 풀다보면 해결될 것 같네요.

눈물과는 별개로 몇 가지 해법을 조합해서 푸는 게 참 재밌었던 문제였습니다.

## 풀이

stack + DP + binary search

먼저 스택으로 각 건물들의 높이마다 최대 수신 가능 메세지 수를 구합니다.
높이가 같은 건물이 없으니 그냥 무지성 저장해도 됩니다.
어쨌든 높이-최대 메세지 수를 key-value로 하는 map으로 저장하면 됩니다.

이때 최대 수신 가능 메세지 수는, 스택에 건물 높이와 더불어, 우측 방향 더 작은 건물 개수의 최댓값(코드에서 `rightCount`)을 같이 저장해서 해결할 수 있습니다.
pop했을 때 스택이 비어있지 않다면, peek.rightCount = max(pop.rightCount + 1, peek.rightCount) 입니다.
1 더한 부분은 방금 pop한 걸 카운트하는 거고, max는 자신보다 작은 건물 개수의 최댓값만 반영하기 위함입니다.

이때 Java SortedMap (TreeMap. 레드 블랙 트리 기반) 이용해서 key 기준으로 자동으로 정렬되게 합니다.
그냥 정렬해도 시간 문제는 없어서 상관없지만, 그냥 편하게 하려고 썼습니다.

이 맵을 정렬된 배열로 만듭니다.
배열은 마찬가지로 높이, 최대 메세지 수 pair로 이루어집니다.
이 배열은 오름차순 정렬되어있고, 정렬 기준은 높이입니다.

이때, 지금 이 상태 그대로면 더 작은 높이의 건물이 더 많은 메세지를 수신하는 것도 가능합니다.
따라서 i = 1 .. n-1에 대해 arr[i] = max(arr[i - 1], arr[i]) 를 한 번 해서 DP 배열로 만듭니다.
이 DP 배열은 각 높이별 "진짜" 최대 수신 가능 메세지 수를 갖습니다.

이제 바이너리 서치로 답을 구합니다.
타워 높이와 건물 높이 모두 unique하므로, 체크할 타워 높이의 lower bound를 DP 배열에서 찾으면 됩니다.
