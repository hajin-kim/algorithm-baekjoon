# 11003번 "최솟값 찾기" 풀이 및 후기

| 바로가기  | <https://www.acmicpc.net/problem/11003> |
|-------|-----------------------------------------|
| 레이팅   | p5                                      |
| 푼 날짜  | 2023-08-29                              |
| 걸린 시간 | 50m                                     |

## 후기

알고리즘 자체는 간단하게 떠올릴 수 있습니다.
구현도 간단해서 작성 끝나기까지 15분 걸렸습니다.

시간초과나서 최적화에 돌입했습니다.
프로파일러 돌려봐도 로직은 멀쩡하고, 입출력 처리가 문제였던 것으로 보였습니다.
그러다가 언어 한계를 느끼고 C++로 다시 짰습니다.
결국 35분 더 걸렸는데...
로직은 첫 코드랑 완전히 똑같더군요.

그래서 Main.kt는 시간초과나는 코드고, main.cpp가 C++로 쓰여진 통과 코드입니다.
아마 java의 입출력 최적화를 어떻게 잘 쓰면 코틀린도 통과시킬 수 있을 것 같습니다.

## 풀이

Deque를 쓰면 O(N)으로 풀 수 있습니다.

Deque는 인덱스와 숫자의 쌍을 저장합니다.
핵심은 몇몇 모노토닉 스택 문제들에서 했던 것처럼 deque를 정렬된 상태로 유지하는 것입니다.

새 숫자 a에 대해 다음을 반복하면 됩니다.

1. Deque의 맨 뒤에서부터 a 이하인 숫자들을 모두 제거합니다.
2. Deque의 맨 뒤에 인덱스와 a의 쌍을 삽입합니다. 이러면 a 앞에 숫자가 있다면 a보다 항상 크고, 인덱스는 a보다 작을 것입니다.
3. Deque의 맨 앞에서부터 인덱스가 지난 것들을 모두 제거합니다.
4. Deque에는 무조건 숫자가 1개 이상 있고, 이 중 맨 앞 숫자가 현재 최솟값입니다.

특징으로는 deque는 숫자로는 내림차순으로 정렬되어 있고, 인덱스로는 오름차순으로 정렬되어 있습니다.

최종적으로 삽입 N번, 제거 N번, 각종 체크들도 O(N)이므로 O(N)입니다.

우선순위 큐를 비슷하게 인덱스와 숫자의 쌍을 저장하도록 해서 O(N log N)으로 풀 수도 있어보입니다.
살짝 더 무겁지만 아슬아슬하게 통과할 수 있을 것 같네요.
혹은 다른 트리 기반 자료구조를 활용하는 것도 방법일 수 있습니다.
